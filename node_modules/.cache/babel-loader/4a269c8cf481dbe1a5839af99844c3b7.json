{"ast":null,"code":"import { firestore } from './../../firebase/utils';\nexport const handleAddCategory = category => {\n  return new Promise((resolve, reject) => {\n    firestore.collection('categories').doc().set(category).then(() => {\n      resolve();\n    }).catch(err => {\n      reject(err);\n    });\n  });\n};\nexport const handleFetchCategories = _ref => {\n  let {\n    filterType,\n    startAfterDoc,\n    persistCategories = []\n  } = _ref;\n  return new Promise((resolve, reject) => {\n    const pageSize = 6; // productCategory possible orderBy\n\n    let ref = firestore.collection('categories').orderBy('createdDate').limit(pageSize); // if (filterType) ref = ref.where('productCategory', '==', filterType);\n\n    if (startAfterDoc) ref = ref.startAfter(startAfterDoc);\n    ref.get().then(snapshot => {\n      const totalCount = snapshot.size;\n      const data = [...persistCategories, ...snapshot.docs.map(doc => {\n        return { ...doc.data(),\n          documentID: doc.id\n        };\n      })];\n      resolve({\n        data,\n        queryDoc: snapshot.docs[totalCount - 1],\n        isLastPage: totalCount < 1\n      });\n    }).catch(err => {\n      reject(err);\n    });\n  });\n};\nexport const handleDeleteCategory = documentID => {\n  return new Promise((resolve, reject) => {\n    firestore.collection('categories').doc(documentID).delete().then(() => {\n      console.log(documentID, 2);\n      resolve();\n    }).catch(err => {\n      reject(err);\n    });\n  });\n};\nexport const handleFetchCategory = categoryID => {\n  return new Promise((resolve, reject) => {\n    firestore.collection('categories').doc(categoryID).get().then(snapshot => {\n      if (snapshot.exists) {\n        resolve({ ...snapshot.data(),\n          documentID: categoryID\n        });\n      }\n    }).catch(err => {\n      reject(err);\n    });\n  });\n};","map":{"version":3,"sources":["/Users/SWT/Desktop/test_shop_crud_copy/src/redux/Categories/categories.helpers.js"],"names":["firestore","handleAddCategory","category","Promise","resolve","reject","collection","doc","set","then","catch","err","handleFetchCategories","filterType","startAfterDoc","persistCategories","pageSize","ref","orderBy","limit","startAfter","get","snapshot","totalCount","size","data","docs","map","documentID","id","queryDoc","isLastPage","handleDeleteCategory","delete","console","log","handleFetchCategory","categoryID","exists"],"mappings":"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","sourcesContent":["import { firestore } from './../../firebase/utils';\n\nexport const handleAddCategory = category => {\n  return new Promise((resolve, reject) => {\n    firestore\n      .collection('categories')\n      .doc()\n      .set(category)\n      .then(() => {\n        resolve();\n      })\n      .catch(err => {\n        reject(err);\n      })\n  });\n}\n\nexport const handleFetchCategories = ({ filterType, startAfterDoc, persistCategories=[] }) => {\n  return new Promise((resolve, reject) => {\n    const pageSize = 6;\n\n    // productCategory possible orderBy\n    let ref = firestore.collection('categories').orderBy('createdDate').limit(pageSize);\n\n    // if (filterType) ref = ref.where('productCategory', '==', filterType);\n    if (startAfterDoc) ref = ref.startAfter(startAfterDoc);\n\n    ref\n      .get()\n      .then(snapshot => {\n        const totalCount = snapshot.size;\n\n        const data = [\n          ...persistCategories,\n          ...snapshot.docs.map(doc => {\n            return {\n              ...doc.data(),\n              documentID: doc.id\n            }\n          })\n        ];\n\n        resolve({\n          data,\n          queryDoc: snapshot.docs[totalCount - 1],\n          isLastPage: totalCount < 1\n        });\n      })\n      .catch(err => {\n        reject(err);\n      })\n  })\n}\n\nexport const handleDeleteCategory = documentID => {\n  return new Promise((resolve, reject) => {\n    firestore\n      .collection('categories')\n      .doc(documentID)\n      .delete()\n      .then(() => {\n        console.log(documentID, 2)\n        resolve();\n      })\n      .catch(err => {\n        reject(err);\n      })\n  });\n}\n\nexport const handleFetchCategory = (categoryID) => {\n  return new Promise((resolve, reject) => {\n    firestore\n      .collection('categories')\n      .doc(categoryID)\n      .get()\n      .then(snapshot => {\n\n        if (snapshot.exists) {\n          resolve({\n            ...snapshot.data(),\n            documentID: categoryID\n          });\n        }\n      })\n      .catch(err => {\n        reject(err);\n      })\n  })\n}"]},"metadata":{},"sourceType":"module"}