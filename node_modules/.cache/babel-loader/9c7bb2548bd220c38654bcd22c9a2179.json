{"ast":null,"code":"import { firestore } from './../../firebase/utils';\nexport const handleAddCategory = category => {\n  return new Promise((resolve, reject) => {\n    firestore.collection('categories').doc().set(category).then(() => {\n      resolve();\n    }).catch(err => {\n      reject(err);\n    });\n  });\n};\nexport const handleFetchCategories = _ref => {\n  let {\n    filterType,\n    startAfterDoc,\n    persistCategories = []\n  } = _ref;\n  return new Promise((resolve, reject) => {\n    const pageSize = 6; // productCategory possible orderBy\n\n    let ref = firestore.collection('categories').orderBy('createdDate').limit(pageSize);\n    if (filterType) ref = ref.where('productCategory', '==', filterType);\n    if (startAfterDoc) ref = ref.startAfter(startAfterDoc);\n    ref.get().then(snapshot => {\n      const totalCount = snapshot.size;\n      const data = [...persistCategories, ...snapshot.docs.map(doc => {\n        return { ...doc.data(),\n          documentID: doc.id\n        };\n      })];\n      resolve({\n        data,\n        queryDoc: snapshot.docs[totalCount - 1],\n        isLastPage: totalCount < 1\n      });\n    }).catch(err => {\n      reject(err);\n    });\n  });\n};\nexport const handleDeleteCategory = documentID => {\n  return new Promise((resolve, reject) => {\n    firestore.collection('categories').doc(documentID).delete().then(() => {\n      console.log(documentID, 2);\n      resolve();\n    }).catch(err => {\n      reject(err);\n    });\n  });\n};\nexport const handleFetchCategory = categoryID => {\n  return new Promise((resolve, reject) => {\n    firestore.collection('categories').doc(categoryID).get().then(snapshot => {\n      if (snapshot.exists) {\n        resolve({ ...snapshot.data(),\n          documentID: categoryID\n        });\n      }\n    }).catch(err => {\n      reject(err);\n    });\n  });\n};","map":{"version":3,"sources":["/Users/SWT/Desktop/test_shop_crud_copy/test_shop_crud_methods/src/redux/Categories/categories.helpers.js"],"names":["firestore","handleAddCategory","category","Promise","resolve","reject","collection","doc","set","then","catch","err","handleFetchCategories","filterType","startAfterDoc","persistCategories","pageSize","ref","orderBy","limit","where","startAfter","get","snapshot","totalCount","size","data","docs","map","documentID","id","queryDoc","isLastPage","handleDeleteCategory","delete","console","log","handleFetchCategory","categoryID","exists"],"mappings":"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","sourcesContent":["import { firestore } from './../../firebase/utils';\n\nexport const handleAddCategory = category => {\n  return new Promise((resolve, reject) => {\n    firestore\n      .collection('categories')\n      .doc()\n      .set(category)\n      .then(() => {\n        resolve();\n      })\n      .catch(err => {\n        reject(err);\n      })\n  });\n}\n\nexport const handleFetchCategories = ({ filterType, startAfterDoc, persistCategories=[] }) => {\n  return new Promise((resolve, reject) => {\n    const pageSize = 6;\n\n    // productCategory possible orderBy\n    let ref = firestore.collection('categories').orderBy('createdDate').limit(pageSize);\n\n    if (filterType) ref = ref.where('productCategory', '==', filterType);\n    if (startAfterDoc) ref = ref.startAfter(startAfterDoc);\n\n    ref\n      .get()\n      .then(snapshot => {\n        const totalCount = snapshot.size;\n\n        const data = [\n          ...persistCategories,\n          ...snapshot.docs.map(doc => {\n            return {\n              ...doc.data(),\n              documentID: doc.id\n            }\n          })\n        ];\n\n        resolve({\n          data,\n          queryDoc: snapshot.docs[totalCount - 1],\n          isLastPage: totalCount < 1\n        });\n      })\n      .catch(err => {\n        reject(err);\n      })\n  })\n}\n\nexport const handleDeleteCategory = documentID => {\n  return new Promise((resolve, reject) => {\n    firestore\n      .collection('categories')\n      .doc(documentID)\n      .delete()\n      .then(() => {\n        console.log(documentID, 2)\n        resolve();\n      })\n      .catch(err => {\n        reject(err);\n      })\n  });\n}\n\nexport const handleFetchCategory = (categoryID) => {\n  return new Promise((resolve, reject) => {\n    firestore\n      .collection('categories')\n      .doc(categoryID)\n      .get()\n      .then(snapshot => {\n\n        if (snapshot.exists) {\n          resolve({\n            ...snapshot.data(),\n            documentID: categoryID\n          });\n        }\n      })\n      .catch(err => {\n        reject(err);\n      })\n  })\n}"]},"metadata":{},"sourceType":"module"}